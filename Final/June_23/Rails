
上月待完成:
    1. 完成May_23未完成的任务


1. 健壮参数中携带Array类型
    demo_array = ["1","2","3"]

    def test_array_params
        require(:demo).permit(:name, :description, demo_array: ["1","2"])  =>  当params中不存在demo_array参数下， test_array_params默认["1","2"] 并且想传递array类型必须按照这个格式
    end

2. 自定义Class增加 自定义Error =>  BatchPublishService模块下增加Error

    给自定义的 ServiceClass || FinderClass || QueryClass 增加Error => Videos:: = Class.new(StandardError)

3. ActiveModel下 class_name与source的用法
       https://www.thinbug.com/q/33852811

4. 定时任务 JobItems表 ScheduleJobUtil HomeworkCommon表的结合使用
   1. ScheduleJobUtil模块 job_items表 结合定时任  并且定时任务执行后能否删除  当前时间大于指定任务的执行数据，定时任务会不会执行
   2.(包括定时任务) => 当定时任务的时间为false或者 true时，会直接执行  2.当定时任务已执行后，是无法删除的(应该是的)
   3.job_item.rb表下重写了 destroy方法 可以学习

5. 自定义validate类校验字段
   1.Users::UpdateAccountForm类写法结合 users/accounts_controller下update方法结合可能详细查看一下(可以当做一个模块使用)
   2.course_second_categories.rb 下 校验name字段 多个字段的唯一写法


6. 科大实验室
   1.
   Reservation.last.reservation_time_specifications => 通过某条reservation找到reservation_time_specifications，并且查的是reservation_time_specifications数据
   如下:
    	SELECT  `reservations`.* FROM `reservations` ORDER BY `reservations`.`id` DESC LIMIT 1
    	SELECT  `reservation_time_specifications`.* FROM `reservation_time_specifications` INNER JOIN `reservation_times` ON `reservation_time_specifications`.`id` = `reservation_times`.`reservation_time_specification_id` WHERE `reservation_times`.`reservation_id` = 44 LIMIT 11
   所以 Reservation.last.reservation_time_specifications.order("reservations.id desc") 报错！！！

   2.
   Reservation.joins(:reservation_times_specifications).order("reservations.id desc")
   默认查出的是 reservation表的数据

7(√). rails结合field使用
    value =  EduSetting.get("subject_index_sort").to_s => "1,3,5,7,892,34"
    # 下面操作
    value.blank? ? return : "FIELD(subjects.id, #{value} ,subjects.id) asc"

8. mysql order(https://blog.csdn.net/Ajekseg/article/details/126036613)
    1.安表中多字段排序: "order by name desc, id asc" =>数据出现相同name情况下，在按照id顺序排列(https://blog.csdn.net/weixin_47702737/article/details/121754963)

    2. case when用法(https://blog.csdn.net/A_Runner/article/details/103136846)
        SELECT
            id,
            visits,
            hidden,
            CONCAT( id, visits, hidden ) test,
            CONCAT( id, visits ) num,
            IF(visits > 10000, 0,1) visitses
        FROM
            subjects
        ORDER BY
        visitses  desc

    3. field用法
        1. 默认用法(https://blog.csdn.net/han_cui/article/details/106219405) => 默认用法有坑: FIELD(name,"kevin","alice") asc  =>将未匹配的kevin与alice放在最前面 匹配到的kevin与alice按照str顺序排序

        2. 	SELECT id, visits, hidden FROM subjects ORDER BY FIELD(id, 6,19,33, id)  => 优先排序6,19,33数据
            =>  SELECT id, visits, hidden FROM subjects ORDER BY FIELD(id, 6,19,id, 33) => 注意: id只能替换最后一个str，如id后还有str，则id后的str无效,将不会匹配排序

        3. 	认真仔细查看
            SELECT
                id,
                visits,
                hidden,
                status,
                FIELD(hidden, 0,1,2) now_hidden,
                FIELD(status, 2,0,1) now_hidden
             FROM
                subjects
             ORDER BY
             FIELD(hidden, 0,1,2) asc , FIELD(status, 2,0,1) asc , FIELD(visits, 60, visits);

        4. FIELD函数根本用法(https://www.moonapi.com/news/26842.html),结合case when用法理解就能明白field用法中1,2,3案列的原理

    4. locate用法


    5. lnstr用法

    6. 利用数据字典实现自定义排序

